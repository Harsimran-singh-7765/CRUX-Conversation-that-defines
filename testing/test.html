<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crux Test Client</title>
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Kalam:wght@700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --color-bg: #1B2021;
            --color-light-green: #D8F8B6;
            --color-blue: #00BFFF;
            --color-pink: #FF69B4;
            --color-yellow: #FFEB3B;
            --color-text-dark: #333;
            --color-text-light: white;
            --border-thickness: 3px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Kalam', cursive, sans-serif;
            background-color: var(--color-light-green);
            color: var(--color-text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            font-size: 16px;
            overflow-x: hidden;
        }

        .main-layout {
            display: flex;
            gap: 2rem;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 1800px;
        }

        .visualizer-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 250px;
        }

        canvas.visualizer {
            display: block;
            filter: drop-shadow(0 0 20px rgba(255, 105, 180, 0.5));
            max-width: 100%;
            height: auto;
        }

        .sketch-box {
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .sketch-box:hover {
            transform: translate(1px, 1px);
            box-shadow: calc(var(--border-thickness) - 1px) calc(var(--border-thickness) - 1px) 0 0 black;
        }

        .sketch-box.interactive:hover {
            cursor: pointer;
        }

        .container {
            flex: 0 0 auto;
            width: 100%;
            max-width: 700px;
            background: var(--color-light-green);
            padding: 1.5rem;
            text-align: center;
            color: var(--color-text-dark);
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
        }

        h1 {
            font-family: 'Permanent Marker', cursive;
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            color: black;
            margin-top: 0;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        h1::after {
            content: 'üéôÔ∏è';
            margin-left: 10px;
            font-size: clamp(1.6rem, 4.5vw, 2.2rem);
            vertical-align: middle;
        }

        #generatorSection {
            padding: 1rem;
            margin-bottom: 1rem;
            background: white;
        }

        #generatorSection h3 {
            font-size: clamp(1.1rem, 3vw, 1.3rem);
            color: black;
            margin-top: 0;
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        #generatorSection h3::before {
            content: '‚ú®';
            font-size: 1.5rem;
        }

        #descriptionInput {
            width: 100%;
            padding: 0.6rem;
            background-color: white;
            color: var(--color-text-dark);
            font-size: clamp(0.85rem, 2vw, 0.9rem);
            margin-bottom: 0.5rem;
            box-sizing: border-box;
            resize: vertical;
            min-height: 160px;
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
            font-family: 'Kalam', cursive, sans-serif;
        }

        #descriptionInput::placeholder {
            color: #888;
        }

        #charCount {
            font-size: clamp(0.75rem, 1.8vw, 0.8rem);
            color: var(--color-text-dark);
            margin-bottom: 0.5rem;
            text-align: right;
            width: 100%;
        }

        #charCount.warning {
            color: var(--color-yellow);
            font-weight: bold;
        }

        #charCount.error {
            color: var(--color-pink);
            font-weight: bold;
        }

        .example-chips {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            justify-content: center;
        }

        .example-chip {
            background: white;
            padding: 0.4rem 0.8rem;
            font-size: clamp(0.75rem, 1.8vw, 0.8rem);
            cursor: pointer;
            color: var(--color-text-dark);
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
            font-family: 'Kalam', cursive, sans-serif;
        }

        .example-chip:hover {
            background: var(--color-blue);
            color: white;
        }

        button {
            font-size: clamp(0.85rem, 2vw, 0.95rem);
            padding: 0.6rem 1.2rem;
            border: none;
            cursor: pointer;
            margin: 0.3rem 0.2rem;
            transition: all 0.1s ease;
            font-weight: bold;
            text-transform: uppercase;
            font-family: 'Kalam', cursive, sans-serif;
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            transform: none;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
        }

        #btnGenerate {
            background-color: var(--color-blue);
            color: white;
            width: 100%;
        }

        #btnStartGame,
        #btnConnect {
            background-color: var(--color-blue);
            color: white;
            margin-bottom: 15px;
        }

        #btnRefreshScenarios {
            background-color: var(--color-yellow);
            color: black;
            padding: 0.4rem 0.8rem;
            font-size: clamp(0.8rem, 1.9vw, 0.9rem);
        }

        #btnPushToTalk {
            background-color: var(--color-pink);
            color: white;
            width: 80%;
            padding: 1rem;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
        }

        #btnPushToTalk:active:not(:disabled) {
            background-color: var(--color-text-dark);
            transform: translate(var(--border-thickness), var(--border-thickness));
            box-shadow: 0 0 0 0 transparent;
        }

        #btnEndGame {
            background-color: var(--color-pink);
            color: white;
        }

        .generator-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        #status {
            font-size: clamp(0.95rem, 2.3vw, 1.1rem);
            font-weight: bold;
            color: black;
            margin: 1rem 0;
            padding: 0.8rem;
            background: white;
            min-height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
        }

        #timer {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: bold;
            color: black;
            margin-bottom: 1rem;
            padding: 8px;
            background: white;
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
        }

        #timer.low {
            color: var(--color-pink);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.03);
            }

            100% {
                transform: scale(1);
            }
        }

        .scenario-selector {
            margin-bottom: 1rem;
            width: 100%;
        }

        .scenario-selector label {
            font-weight: bold;
            font-size: clamp(0.9rem, 2.2vw, 1rem);
            color: black;
        }

        .scenario-header {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
        }

        #scenarioSelect {
            flex: 1;
            padding: 0.6rem;
            font-size: clamp(0.85rem, 2vw, 0.9rem);
            color: var(--color-text-dark);
            background-color: white;
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
            font-family: 'Kalam', cursive, sans-serif;
        }

        #chatLog {
            width: 100%;
            height: 200px;
            overflow-y: scroll;
            padding: 0.8rem;
            margin-bottom: 1rem;
            text-align: left;
            background: #fff;
            box-sizing: border-box;
            color: var(--color-text-dark);
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
            font-family: 'Kalam', cursive, sans-serif;
            font-size: clamp(0.8rem, 1.9vw, 0.85rem);
        }

        .message {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0.8rem;
            max-width: 75%;
            word-wrap: break-word;
            border: 1px solid #ccc;
            box-shadow: 1px 1px 0 0 #ccc;
        }

        .message.user {
            background-color: var(--color-blue);
            color: white;
            margin-left: auto;
            border-color: var(--color-blue);
            box-shadow: 1px 1px 0 0 var(--color-blue);
        }

        .message.ai {
            background-color: #e0e0e0;
            color: var(--color-text-dark);
            margin-right: auto;
            border-color: #e0e0e0;
            box-shadow: 1px 1px 0 0 #e0e0e0;
        }

        .message.ai.spam {
            background-color: var(--color-pink);
            color: white;
            animation: spamPop 0.3s ease-out;
            font-weight: bold;
            border-color: var(--color-pink);
            box-shadow: 1px 1px 0 0 var(--color-pink);
        }

        @keyframes spamPop {
            0% {
                transform: scale(0.9) translateX(-10px);
                opacity: 0;
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1) translateX(0);
                opacity: 1;
            }
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0.5rem 0.8rem;
            background-color: #e0e0e0;
            max-width: 80px;
            margin-right: auto;
            margin-bottom: 0.5rem;
            border: 1px solid #ccc;
            box-shadow: 1px 1px 0 0 #ccc;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            background-color: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {

            0%,
            60%,
            100% {
                transform: translateY(0);
            }

            30% {
                transform: translateY(-10px);
            }
        }

        #results {
            margin-top: 1rem;
            font-size: clamp(0.9rem, 2.2vw, 1rem);
            color: black;
            background-color: white;
            padding: 1rem;
            border: var(--border-thickness) solid black;
            box-shadow: var(--border-thickness) var(--border-thickness) 0 0 black;
        }

        #results h3 {
            font-size: clamp(1.1rem, 2.8vw, 1.3rem);
            color: black;
            margin-top: 0;
            margin-bottom: 0.8rem;
        }

        #results p {
            margin-bottom: 0;
        }

        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Tablet & smaller laptops */
        @media (max-width: 1200px) {
            .main-layout {
                flex-direction: column;
                gap: 1.5rem;
            }

            .visualizer-container {
                display: none;
            }

            .container {
                max-width: 600px;
            }
        }

        /* Mobile landscape & small tablets */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .container {
                padding: 1rem;
            }

            #chatLog {
                height: 150px;
            }

            .example-chips {
                gap: 0.4rem;
            }

            .message {
                max-width: 85%;
            }

            button {
                margin: 0.2rem 0.1rem;
            }
        }

        /* Mobile portrait */
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 0.8rem;
            }

            h1::after {
                display: block;
                margin-left: 0;
                margin-top: 0.3rem;
            }

            #generatorSection {
                padding: 0.8rem;
            }

            #generatorSection h3 {
                font-size: 1rem;
            }

            .example-chip {
                padding: 0.3rem 0.6rem;
                font-size: 0.75rem;
            }

            button {
                padding: 0.5rem 1rem;
            }

            #btnPushToTalk {
                width: 90%;
                padding: 0.8rem;
            }

            #chatLog {
                height: 120px;
                padding: 0.6rem;
            }

            .message {
                max-width: 90%;
                padding: 0.4rem 0.6rem;
            }

            #descriptionInput {
                min-height: 70px;
                font-size: 0.85rem;
            }
        }

        /* Very small screens */
        @media (max-width: 360px) {
            .container {
                padding: 0.6rem;
            }

            .example-chip {
                font-size: 0.7rem;
                padding: 0.25rem 0.5rem;
            }

            #chatLog {
                height: 100px;
            }
        }
    </style> ```
</head>

<body>

    <div class="main-layout">
        <!-- Left Visualizer -->
        <div class="visualizer-container">
            <canvas id="visualizerLeft" class="visualizer" width="250" height="250"></canvas>
        </div>

        <!-- Main Content -->
        <div class="container">
            <h1>Crux </h1>

            <div id="generatorSection" class="sketch-box">
                <h3>Create Custom Scenario</h3>
                <textarea id="descriptionInput"
                    placeholder="Describe a difficult conversation situation... (10-500 characters)&#10;&#10;Examples:&#10;‚Ä¢ My mom caught me coming home at 3 AM&#10;‚Ä¢ Boss is angry about missed deadline&#10;‚Ä¢ Roommate keeps eating my food"
                    maxlength="500"></textarea>
                <div id="charCount">0 / 500 characters</div>

                <div class="example-chips">
                    <div class="example-chip sketch-box interactive"
                        data-example="My mom caught me sneaking in at 3 AM smelling of alcohol">üè† Late Night</div>
                    <div class="example-chip sketch-box interactive"
                        data-example="My boss is furious I missed an important client deadline">üíº Missed Deadline</div>
                    <div class="example-chip sketch-box interactive"
                        data-example="My roommate keeps eating my food without asking">üçï Food Thief</div>
                    <div class="example-chip sketch-box interactive"
                        data-example="A taxi driver is taking a suspicious route late at night">üöï Sketchy Taxi</div>
                </div>

                <div class="generator-buttons">
                    <button id="btnGenerate" disabled class="sketch-box">
                        ü§ñ Generate Scenario with AI
                    </button>
                </div>
            </div>

            <div class="scenario-selector">
                <label style="display: block; margin-bottom: 0.5rem;">
                    Choose Scenario:
                </label>
                <div class="scenario-header">
                    <select id="scenarioSelect" class="sketch-box">
                        <option value="">Loading scenarios...</option>
                    </select>
                    <button id="btnRefreshScenarios" title="Refresh scenario list" class="sketch-box">üîÑ</button>
                </div>
            </div>

            <button id="btnStartGame" class="sketch-box">1. Start New Game</button>
            <button id="btnConnect" disabled class="sketch-box">2. Connect WebSocket</button>

            <div id="timer" class="sketch-box">Time left: 2:00</div>

            <div id="status" class="sketch-box">Waiting to start...</div>
            <div id="chatLog" class="sketch-box"></div>

            <button id="btnPushToTalk" disabled class="sketch-box">Hold to Speak</button>
            <button id="btnEndGame" disabled class="sketch-box">End Game & Get Score</button>

            <div id="results" class="sketch-box"></div>
        </div>

        <!-- Right Visualizer -->
        <div class="visualizer-container">
            <canvas id="visualizerRight" class="visualizer" width="250" height="250"></canvas>
        </div>
    </div>

    <audio id="audioPlayer"></audio>

    <script>
        // DOM Elements
        const btnStartGame = document.getElementById('btnStartGame');
        const btnConnect = document.getElementById('btnConnect');
        const btnPushToTalk = document.getElementById('btnPushToTalk');
        const btnEndGame = document.getElementById('btnEndGame');
        const btnGenerate = document.getElementById('btnGenerate');
        const btnRefreshScenarios = document.getElementById('btnRefreshScenarios');
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        const audioPlayer = document.getElementById('audioPlayer');
        const chatLog = document.getElementById('chatLog');
        const timerDiv = document.getElementById('timer');
        const scenarioSelect = document.getElementById('scenarioSelect');
        const descriptionInput = document.getElementById('descriptionInput');
        const charCount = document.getElementById('charCount');
        const exampleChips = document.querySelectorAll('.example-chip');

        // Visualizer Setup
        const canvasLeft = document.getElementById('visualizerLeft');
        const canvasRight = document.getElementById('visualizerRight');
        const ctxLeft = canvasLeft.getContext('2d');
        const ctxRight = canvasRight.getContext('2d');

        let audioContext;
        let analyser;
        let dataArray;
        let bufferLength;
        let animationId;
        let micAnalyser;
        let micDataArray;
        let micBufferLength;
        let micStream;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                const source = audioContext.createMediaElementSource(audioPlayer);
                source.connect(analyser);
                analyser.connect(audioContext.destination);

                drawVisualizers();
            }
        }

        async function initMicVisualizer(stream) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            micAnalyser = audioContext.createAnalyser();
            micAnalyser.fftSize = 512;
            micBufferLength = micAnalyser.frequencyBinCount;
            micDataArray = new Uint8Array(micBufferLength);

            const micSource = audioContext.createMediaStreamSource(stream);
            micSource.connect(micAnalyser);

            if (!animationId) {
                drawVisualizers();
            }
        }

        function stopMicVisualizer() {
            micAnalyser = null;
            micDataArray = null;
        }

        function drawVisualizers() {
            animationId = requestAnimationFrame(drawVisualizers);

            // Left visualizer for AI audio
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                drawRadialVisualizer(ctxLeft, canvasLeft, dataArray);
            } else {
                drawRadialVisualizer(ctxLeft, canvasLeft, new Uint8Array(128));
            }

            // Right visualizer for user mic
            if (micAnalyser && micDataArray) {
                micAnalyser.getByteFrequencyData(micDataArray);
                drawRadialVisualizer(ctxRight, canvasRight, micDataArray);
            } else {
                drawRadialVisualizer(ctxRight, canvasRight, new Uint8Array(128));
            }
        }

        function drawRadialVisualizer(ctx, canvas, data) {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;

            ctx.fillStyle = 'transparent';
            ctx.clearRect(0, 0, width, height);

            const bars = 128;
            const barWidth = 3;

            for (let i = 0; i < bars; i++) {
                const value = data[Math.floor(i * data.length / bars)] || 0;
                const barHeight = (value / 255) * radius * 0.8;
                const angle = (i / bars) * Math.PI * 2;

                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                const y2 = centerY + Math.sin(angle) * (radius + barHeight);

                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, '#00BFFF');
                gradient.addColorStop(0.5, '#FF69B4');
                gradient.addColorStop(1, '#FFEB3B');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = barWidth;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 5, 0, Math.PI * 2);
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        audioPlayer.addEventListener('play', () => {
            initAudioContext();
        });

        // State
        let sessionId = null;
        let socket = null;
        let mediaRecorder = null;
        let audioQueue = [];
        let timerInterval = null;
        let timeLeft = 120;
        let typingIndicator = null;
        let pendingAIMessage = '';
        let isTimerPaused = false;
        let isSpamMode = false;
        let spamQueue = [];

        // Config
        const API_URL = "http://127.0.0.1:8000";
        const WS_URL = "ws://127.0.0.1:8000";
        const TEST_USER_ID = "html_test_user";

        // Initialize
        loadScenarios();

        // Scenario Generator
        descriptionInput.addEventListener('input', () => {
            const length = descriptionInput.value.length;
            charCount.textContent = `${length} / 500 characters`;

            if (length < 10) {
                charCount.classList.remove('warning', 'error');
                btnGenerate.disabled = true;
            } else if (length > 450) {
                charCount.classList.add('warning');
                charCount.classList.remove('error');
                btnGenerate.disabled = false;
            } else {
                charCount.classList.remove('warning', 'error');
                btnGenerate.classList.remove('error');
                btnGenerate.disabled = false;
            }
        });

        exampleChips.forEach(chip => {
            chip.addEventListener('click', () => {
                descriptionInput.value = chip.dataset.example;
                descriptionInput.dispatchEvent(new Event('input'));
            });
        });

        btnGenerate.onclick = async () => {
            const description = descriptionInput.value.trim();
            if (description.length < 10 || description.length > 500) {
                updateStatus("Description must be 10-500 characters");
                return;
            }

            btnGenerate.disabled = true;
            btnGenerate.innerHTML = '<span class="loading"></span> Generating...';
            updateStatus("ü§ñ AI is creating your scenario...");

            try {
                const response = await fetch(`${API_URL}/api/v1/scenarios/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ description })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to generate scenario');
                }

                const data = await response.json();
                updateStatus(`‚úÖ Created: ${data.scenario.title}`);

                descriptionInput.value = '';
                charCount.textContent = '0 / 500 characters';

                await loadScenarios();
                scenarioSelect.value = data.scenario.id;

            } catch (err) {
                updateStatus(`‚ùå Error: ${err.message}`);
                console.error("Generation Error:", err);
            } finally {
                btnGenerate.disabled = false;
                btnGenerate.textContent = 'ü§ñ Generate Scenario with AI';
            }
        };

        btnRefreshScenarios.onclick = async () => {
            await loadScenarios();
        };

        async function loadScenarios() {
            btnRefreshScenarios.disabled = true;
            try {
                const response = await fetch(`${API_URL}/api/v1/scenarios/`);
                if (!response.ok) throw new Error('Failed to load scenarios');

                const scenarios = await response.json();

                scenarioSelect.innerHTML = '';
                scenarios.forEach(scenario => {
                    const option = document.createElement('option');
                    option.value = scenario.id;
                    option.textContent = scenario.title;
                    scenarioSelect.appendChild(option);
                });

                if (scenarios.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = 'No scenarios available';
                    scenarioSelect.appendChild(option);
                }

            } catch (err) {
                console.error("Error loading scenarios:", err);
                scenarioSelect.innerHTML = '<option>Error loading scenarios</option>';
            } finally {
                btnRefreshScenarios.disabled = false;
            }
        }

        function getSelectedScenarioId() {
            return scenarioSelect.value;
        }

        btnStartGame.onclick = async () => {
            const scenarioId = getSelectedScenarioId();
            if (!scenarioId) {
                updateStatus("Please select a scenario first");
                return;
            }

            const scenarioTitle = scenarioSelect.options[scenarioSelect.selectedIndex].text;

            updateStatus("Starting game...");
            chatLog.innerHTML = "";
            resultsDiv.innerHTML = "";
            updateTimerDisplay();
            try {
                const response = await fetch(`${API_URL}/api/v1/game/start/${scenarioId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: TEST_USER_ID })
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                sessionId = data.session_id;
                updateStatus(`Game created! Scenario: ${scenarioTitle}`);
                btnStartGame.disabled = true;
                btnConnect.disabled = false;
                scenarioSelect.disabled = true;
                btnRefreshScenarios.disabled = true;
                descriptionInput.disabled = true;
                btnGenerate.disabled = true;
                pendingAIMessage = data.conversation_history[0].message;
            } catch (err) {
                updateStatus(`Error starting game: ${err.message}`);
                console.error("Fetch Error:", err);
            }
        };

        btnConnect.onclick = () => {
            if (!sessionId) {
                updateStatus("No session ID. Start a game first.");
                return;
            }
            updateStatus("Connecting to WebSocket...");
            const url = `${WS_URL}/api/v1/game/ws/${sessionId}`;
            console.log("Connecting to:", url);
            socket = new WebSocket(url);
            socket.binaryType = 'blob';

            socket.onopen = () => {
                updateStatus("Connected! AI will speak first.");
                btnConnect.disabled = true;
                btnEndGame.disabled = false;
                startTimer();
            };

            socket.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    handleJsonMessage(JSON.parse(event.data));
                } else {
                    handleAudioChunk(event.data);
                }
            };

            socket.onerror = (err) => {
                updateStatus(`WebSocket Error: Check console.`);
                console.error("WebSocket Error:", err);
                stopTimer();
            };

            socket.onclose = (event) => {
                updateStatus(`WebSocket Closed. Code: ${event.code}`);
                console.log("WebSocket Close Event:", event);
                enableAll(false);
                stopTimer();
            };
        };

        function handleJsonMessage(data) {
            console.log("Handling JSON:", data);
            switch (data.status) {
                case "angry_spam_streak":
                    updateStatus("‚ö†Ô∏è ANGRY SPAM INCOMING!");
                    isSpamMode = true;
                    spamQueue = [];
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    showTypingIndicator();
                    break;

                case "spam_message":
                    console.log(`Spam ${data.index + 1}/${data.total}: ${data.text}`);
                    spamQueue.push({
                        text: data.text,
                        index: data.index,
                        audio: null
                    });
                    break;

                case "spam_streak_complete":
                    updateStatus("Processing spam streak...");
                    playSpamStreak();
                    break;

                case "ai_speaking":
                    updateStatus("AI is speaking...");
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    audioQueue = [];
                    showTypingIndicator();
                    break;

                case "ai_finished_speaking":
                    updateStatus("Your turn. Hold to speak.");
                    btnPushToTalk.disabled = false;
                    btnEndGame.disabled = false;
                    if (!isSpamMode) {
                        playFullAudio();
                    }
                    break;

                case "ai_thinking":
                    updateStatus("AI is thinking...");
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    break;

                case "evaluating":
                    updateStatus("Evaluating your performance...");
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    stopTimer();
                    break;

                case "game_over":
                    updateStatus("Game Over!");
                    resultsDiv.innerHTML = `
                        <h3>Final Score: ${data.score}/10</h3>
                        <p><strong>Justification:</strong> ${data.justification}</p>
                    `;
                    stopTimer();
                    socket.close();
                    break;

                case "user_response_text":
                    addMessageToChat('user', data.text);
                    break;

                case "ai_response_text":
                    if (data.text && data.text.includes("BREAK")) {
                        console.log("üî• Spam response detected, skipping normal display");
                    } else if (!isSpamMode) {
                        pendingAIMessage = data.text;
                    }
                    break;

                case "error":
                    updateStatus(`Error: ${data.message}`);
                    break;
            }
        }

        function handleAudioChunk(audioChunk) {
            if (isSpamMode && spamQueue.length > 0) {
                for (let i = 0; i < spamQueue.length; i++) {
                    if (!spamQueue[i].audio) {
                        spamQueue[i].audio = audioChunk;
                        console.log(`Assigned audio to spam message ${i}`);
                        break;
                    }
                }
            } else {
                audioQueue.push(audioChunk);
            }
        }

        function playFullAudio() {
            if (audioQueue.length === 0) return;
            console.log("Combining audio chunks and playing...");
            const fullAudioBlob = new Blob(audioQueue, { type: 'audio/wav' });
            const audioUrl = URL.createObjectURL(fullAudioBlob);
            audioPlayer.src = audioUrl;

            audioPlayer.onplay = () => {
                hideTypingIndicator();
                pauseTimer();
                if (pendingAIMessage) {
                    addMessageToChat('ai', pendingAIMessage);
                    pendingAIMessage = '';
                }
            };

            audioPlayer.onended = () => {
                resumeTimer();
            };

            audioPlayer.play().catch(e => console.error("Audio play error:", e));
            audioQueue = [];
        }

        async function playSpamStreak() {
            console.log(`Playing spam streak with ${spamQueue.length} messages`);
            hideTypingIndicator();
            pauseTimer();

            for (let i = 0; i < spamQueue.length; i++) {
                const spam = spamQueue[i];
                addMessageToChat('ai', spam.text, true);

                if (spam.audio) {
                    const audioBlob = new Blob([spam.audio], { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayer.src = audioUrl;

                    await new Promise((resolve) => {
                        audioPlayer.onended = resolve;
                        audioPlayer.play().catch(e => {
                            console.error("Spam audio play error:", e);
                            resolve();
                        });
                    });

                    await new Promise(r => setTimeout(r, 200));
                }
            }

            isSpamMode = false;
            spamQueue = [];
            resumeTimer();
            updateStatus("Your turn. Hold to speak.");
            btnPushToTalk.disabled = false;
            btnEndGame.disabled = false;
        }

        btnPushToTalk.onmousedown = async () => {
            if (!socket) return;

            // Interrupt AI audio if playing
            if (!audioPlayer.paused) {
                console.log("üö´ Interrupting AI audio - user started speaking");
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
                resumeTimer();
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                micStream = stream;

                // Initialize mic visualizer
                await initMicVisualizer(stream);

                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && socket.readyState === WebSocket.OPEN) {
                        socket.send(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    if (socket.readyState === WebSocket.OPEN) {
                        sendJson({ action: "stop_speaking" });
                    }
                    stream.getTracks().forEach(track => track.stop());
                    stopMicVisualizer();
                };

                mediaRecorder.start(500);
                sendJson({ action: "start_speaking" });
                updateStatus("Listening... Release to stop.");

            } catch (err) {
                updateStatus(`Mic error: ${err.message}`);
                console.error("Microphone Error:", err);
            }
        };

        btnPushToTalk.onmouseup = () => {
            if (mediaRecorder) {
                mediaRecorder.stop();
                updateStatus("AI is thinking...");
            }
        };

        btnEndGame.onclick = () => {
            endGame();
        };

        function startTimer() {
            timeLeft = 120;
            isTimerPaused = false;
            updateTimerDisplay();
            stopTimer();

            timerInterval = setInterval(() => {
                if (!isTimerPaused) {
                    timeLeft--;
                    updateTimerDisplay();

                    if (timeLeft <= 30) {
                        timerDiv.classList.add('low');
                    }

                    if (timeLeft <= 0) {
                        console.log("Timer finished, auto-ending game.");
                        stopTimer();
                        endGame(true);
                    }
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timeLeft = 120;
            isTimerPaused = false;
            timerDiv.classList.remove('low');
        }

        function pauseTimer() {
            console.log("‚è∏Ô∏è Timer paused (audio playing)");
            isTimerPaused = true;
        }

        function resumeTimer() {
            console.log("‚ñ∂Ô∏è Timer resumed (audio finished)");
            isTimerPaused = false;
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            const pauseIndicator = isTimerPaused ? ' ‚è∏Ô∏è' : '';
            timerDiv.textContent = `Time left: ${minutes}:${seconds.toString().padStart(2, '0')}${pauseIndicator}`;
        }

        function endGame(isAutoEnd = false) {
            if (isAutoEnd) {
                updateStatus("Time's up! Evaluating...");
            } else {
                console.log("User clicked End Game.");
            }
            sendJson({ action: "end_game" });
            btnPushToTalk.disabled = true;
            btnEndGame.disabled = true;
        }

        function addMessageToChat(role, text, isSpam = false) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message', role);
            if (isSpam) {
                msgDiv.classList.add('spam');
            }
            msgDiv.textContent = text;
            chatLog.appendChild(msgDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function showTypingIndicator() {
            hideTypingIndicator();
            typingIndicator = document.createElement('div');
            typingIndicator.classList.add('typing-indicator');
            typingIndicator.innerHTML = '<span></span><span></span><span></span>';
            chatLog.appendChild(typingIndicator);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function hideTypingIndicator() {
            if (typingIndicator && typingIndicator.parentNode) {
                typingIndicator.parentNode.removeChild(typingIndicator);
                typingIndicator = null;
            }
        }

        function sendJson(data) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("Sending JSON:", data);
                socket.send(JSON.stringify(data));
            }
        }

        function updateStatus(message) {
            console.log("Status:", message);
            statusDiv.textContent = message;
        }

        function enableAll(all = true) {
            if (all) {
                btnStartGame.disabled = false;
                scenarioSelect.disabled = false;
                btnRefreshScenarios.disabled = false;
                descriptionInput.disabled = false;
                btnGenerate.disabled = descriptionInput.value.length < 10;
            }
            btnConnect.disabled = true;
            btnPushToTalk.disabled = true;
            btnEndGame.disabled = true;
        }
    </script>
</body>

</html>