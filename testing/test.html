<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crux Test Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #FFFDEB;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 600px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            padding: 2rem;
            text-align: center;
        }
        h1 {
            color: #D9534F;
            margin-top: 0;
        }
        #status {
            font-size: 1.2rem;
            font-weight: bold;
            color: #5BC0DE;
            margin: 1rem 0;
            padding: 1rem;
            background: #f0f8ff;
            border-radius: 8px;
            min-height: 2rem;
        }
        
        #timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #5CB85C;
            margin-bottom: 1rem;
        }
        #timer.low {
            color: #D9534F;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #chatLog {
            width: 100%;
            height: 200px;
            overflow-y: scroll;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            text-align: left;
            background: #f9f9f9;
            box-sizing: border-box; 
        }
        .message {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0.8rem;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .message.user {
            background-color: #5BC0DE;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0;
        }
        .message.ai {
            background-color: #e0e0e0;
            color: #333;
            margin-right: auto;
            border-bottom-left-radius: 0;
        }
        
        /* SPAM EFFECT */
        .message.ai.spam {
            background-color: #ff6b6b;
            color: white;
            animation: spamPop 0.3s ease-out;
            font-weight: bold;
        }
        @keyframes spamPop {
            0% { 
                transform: scale(0.8) translateX(-20px);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% { 
                transform: scale(1) translateX(0);
                opacity: 1;
            }
        }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0.5rem 0.8rem;
            background-color: #e0e0e0;
            border-radius: 10px;
            max-width: 80px;
            margin-right: auto;
            margin-bottom: 0.5rem;
        }
        .typing-indicator span {
            width: 8px;
            height: 8px;
            background-color: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }
        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        button {
            font-size: 1rem;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.2s ease;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        #btnStartGame, #btnConnect {
            background-color: #5CB85C;
            color: white;
        }
        #btnPushToTalk {
            background-color: #5BC0DE;
            color: white;
            width: 80%;
            padding: 1rem;
            font-size: 1.2rem;
        }
        #btnPushToTalk:active:not(:disabled) {
            background-color: #D9534F;
            transform: scale(0.98);
        }
        #btnEndGame {
            background-color: #f0ad4e;
            color: white;
        }
        #results {
            margin-top: 1.5rem;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Crux Test Client üéôÔ∏è</h1>
        
        <div style="margin-bottom: 1rem;">
            <label for="scenarioSelect" style="display: block; margin-bottom: 0.5rem; font-weight: bold;">
                Choose Scenario:
            </label>
            <select id="scenarioSelect" style="width: 100%; padding: 0.5rem; font-size: 1rem; border-radius: 4px; border: 1px solid #ddd;">
                <option value="drunk_driving_incident">üöî Caught Drunk Driving</option>
                <option value="forgotten_birthday" selected>üéÇ The Forgotten Birthday</option>
                <option value="apologetic_boyfriend">üíî The Makeup Call</option>
                <option value="creepy_freshman">üò® The Persistent Freshman</option>
                <option value="sketchy_taxi_driver">üöï The Late Night Taxi</option>
                <option value="annoying_roommate">üè† The Messy Roommate</option>
                <option value="suspicious_job_interview">üíº The Sketchy Job Interview</option>
                <option value="toxic_friend_guilt_trip">üé≠ The Guilt-Tripping Friend</option>
            </select>
        </div>
        
        <button id="btnStartGame">1. Start New Game</button>
        <button id="btnConnect" disabled>2. Connect WebSocket</button>

        <div id="timer">Time left: 2:00</div>

        <div id="status">Waiting to start...</div>
        <div id="chatLog"></div>

        <button id="btnPushToTalk" disabled>Hold to Speak</button>
        <button id="btnEndGame" disabled>End Game & Get Score</button>

        <div id="results"></div>
    </div>

    <audio id="audioPlayer"></audio>

    <script>
        // --- DOM Elements ---
        const btnStartGame = document.getElementById('btnStartGame');
        const btnConnect = document.getElementById('btnConnect');
        const btnPushToTalk = document.getElementById('btnPushToTalk');
        const btnEndGame = document.getElementById('btnEndGame');
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        const audioPlayer = document.getElementById('audioPlayer');
        const chatLog = document.getElementById('chatLog');
        const timerDiv = document.getElementById('timer');
        const scenarioSelect = document.getElementById('scenarioSelect');

        // --- State ---
        let sessionId = null;
        let socket = null;
        let mediaRecorder = null;
        let audioQueue = [];
        let timerInterval = null;
        let timeLeft = 120;
        let typingIndicator = null;
        let pendingAIMessage = '';
        let isTimerPaused = false; // NEW: Track if timer is paused
        
        // SPAM STREAK STATE
        let isSpamMode = false;
        let spamQueue = [];

        // --- Config ---
        const API_URL = "http://127.0.0.1:8000";
        const WS_URL = "ws://127.0.0.1:8000";
        const TEST_USER_ID = "html_test_user";
        
        // Get selected scenario ID
        function getSelectedScenarioId() {
            return scenarioSelect.value;
        }

        // --- 1. Start Game (REST API) ---
        btnStartGame.onclick = async () => {
            const scenarioId = getSelectedScenarioId();
            const scenarioTitle = scenarioSelect.options[scenarioSelect.selectedIndex].text;
            
            updateStatus("Starting game...");
            chatLog.innerHTML = "";
            resultsDiv.innerHTML = "";
            updateTimerDisplay();
            try {
                const response = await fetch(`${API_URL}/api/v1/game/start/${scenarioId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: TEST_USER_ID })
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                sessionId = data.session_id;
                updateStatus(`Game created! Scenario: ${scenarioTitle}`);
                btnStartGame.disabled = true;
                btnConnect.disabled = false;
                scenarioSelect.disabled = true;
                pendingAIMessage = data.conversation_history[0].message;
            } catch (err) {
                updateStatus(`Error starting game: ${err.message}`);
                console.error("Fetch Error:", err);
            }
        };

        // --- 2. Connect WebSocket ---
        btnConnect.onclick = () => {
            if (!sessionId) {
                updateStatus("No session ID. Start a game first.");
                return;
            }
            updateStatus("Connecting to WebSocket...");
            const url = `${WS_URL}/api/v1/game/ws/${sessionId}`;
            console.log("Connecting to:", url);
            socket = new WebSocket(url);
            socket.binaryType = 'blob';

            socket.onopen = () => {
                updateStatus("Connected! AI will speak first.");
                btnConnect.disabled = true;
                btnEndGame.disabled = false;
                startTimer();
            };

            socket.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    handleJsonMessage(JSON.parse(event.data));
                } else {
                    handleAudioChunk(event.data);
                }
            };

            socket.onerror = (err) => {
                updateStatus(`WebSocket Error: Check console.`);
                console.error("WebSocket Error:", err);
                stopTimer();
            };

            socket.onclose = (event) => {
                updateStatus(`WebSocket Closed. Code: ${event.code}`);
                console.log("WebSocket Close Event:", event);
                enableAll(false);
                stopTimer();
            };
        };

        // --- 3. Handle JSON Messages ---
        function handleJsonMessage(data) {
            console.log("Handling JSON:", data);
            switch (data.status) {
                case "angry_spam_streak":
                    updateStatus("‚ö†Ô∏è ANGRY SPAM INCOMING!");
                    isSpamMode = true;
                    spamQueue = [];
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    showTypingIndicator();
                    break;
                    
                case "spam_message":
                    console.log(`Spam ${data.index + 1}/${data.total}: ${data.text}`);
                    spamQueue.push({
                        text: data.text,
                        index: data.index,
                        audio: null
                    });
                    break;
                    
                case "spam_streak_complete":
                    updateStatus("Processing spam streak...");
                    playSpamStreak();
                    break;
                    
                case "ai_speaking":
                    updateStatus("AI is speaking...");
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    audioQueue = [];
                    showTypingIndicator();
                    break;
                    
                case "ai_finished_speaking":
                    updateStatus("Your turn. Hold to speak.");
                    btnPushToTalk.disabled = false;
                    btnEndGame.disabled = false;
                    if (!isSpamMode) {
                        playFullAudio();
                    }
                    break;
                    
                case "ai_thinking":
                    updateStatus("AI is thinking...");
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    break;
                    
                case "evaluating":
                    updateStatus("Evaluating your performance...");
                    btnPushToTalk.disabled = true;
                    btnEndGame.disabled = true;
                    stopTimer();
                    break;
                    
                case "game_over":
                    updateStatus("Game Over!");
                    resultsDiv.innerHTML = `
                        <h3>Final Score: ${data.score}/10</h3>
                        <p><strong>Justification:</strong> ${data.justification}</p>
                    `;
                    stopTimer();
                    socket.close();
                    break;
                    
                case "user_response_text":
                    addMessageToChat('user', data.text);
                    break;
                    
                case "ai_response_text":
                    // Check if this is a spam response (contains BREAK)
                    if (data.text && data.text.includes("BREAK")) {
                        console.log("üî• Spam response detected, skipping normal display");
                        // Don't store it - spam messages will be shown individually
                    } else if (!isSpamMode) {
                        pendingAIMessage = data.text;
                    }
                    break;
                    
                case "error":
                    updateStatus(`Error: ${data.message}`);
                    break;
            }
        }

        // --- 4. Handle Audio ---
        function handleAudioChunk(audioChunk) {
            if (isSpamMode && spamQueue.length > 0) {
                // Assign audio to the last spam message that doesn't have audio yet
                for (let i = 0; i < spamQueue.length; i++) {
                    if (!spamQueue[i].audio) {
                        spamQueue[i].audio = audioChunk;
                        console.log(`Assigned audio to spam message ${i}`);
                        break;
                    }
                }
            } else {
                audioQueue.push(audioChunk);
            }
        }

        function playFullAudio() {
            if (audioQueue.length === 0) return;
            console.log("Combining audio chunks and playing...");
            const fullAudioBlob = new Blob(audioQueue, { type: 'audio/wav' });
            const audioUrl = URL.createObjectURL(fullAudioBlob);
            audioPlayer.src = audioUrl;
            
            audioPlayer.onplay = () => {
                hideTypingIndicator();
                pauseTimer(); // Pause timer when audio starts
                if (pendingAIMessage) {
                    addMessageToChat('ai', pendingAIMessage);
                    pendingAIMessage = '';
                }
            };
            
            audioPlayer.onended = () => {
                resumeTimer(); // Resume timer when audio ends
            };
            
            audioPlayer.play().catch(e => console.error("Audio play error:", e));
            audioQueue = [];
        }
        
        // --- SPAM STREAK PLAYER ---
        async function playSpamStreak() {
            console.log(`Playing spam streak with ${spamQueue.length} messages`);
            hideTypingIndicator();
            pauseTimer(); // Pause timer for entire spam streak
            
            for (let i = 0; i < spamQueue.length; i++) {
                const spam = spamQueue[i];
                
                // Add message to chat with spam styling
                addMessageToChat('ai', spam.text, true);
                
                // Play audio if available
                if (spam.audio) {
                    const audioBlob = new Blob([spam.audio], { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayer.src = audioUrl;
                    
                    // Wait for this audio to finish before next message
                    await new Promise((resolve) => {
                        audioPlayer.onended = resolve;
                        audioPlayer.play().catch(e => {
                            console.error("Spam audio play error:", e);
                            resolve();
                        });
                    });
                    
                    // Small delay between spam messages for effect
                    await new Promise(r => setTimeout(r, 200));
                }
            }
            
            // Reset spam mode
            isSpamMode = false;
            spamQueue = [];
            resumeTimer(); // Resume timer after spam streak ends
            updateStatus("Your turn. Hold to speak.");
            btnPushToTalk.disabled = false;
            btnEndGame.disabled = false;
        }

        // --- 5. Push-to-Talk ---
        btnPushToTalk.onmousedown = async () => {
            if (!socket) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' }); 

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && socket.readyState === WebSocket.OPEN) {
                        socket.send(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    if (socket.readyState === WebSocket.OPEN) {
                        sendJson({ action: "stop_speaking" });
                    }
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start(500);
                sendJson({ action: "start_speaking" });
                updateStatus("Listening... Release to stop.");

            } catch (err) {
                updateStatus(`Mic error: ${err.message}`);
                console.error("Microphone Error:", err);
            }
        };

        btnPushToTalk.onmouseup = () => {
            if (mediaRecorder) {
                mediaRecorder.stop();
                updateStatus("AI is thinking...");
            }
        };

        // --- 6. End Game Button ---
        btnEndGame.onclick = () => {
            endGame();
        };

        // --- 7. Timer Functions ---
        function startTimer() {
            timeLeft = 120;
            isTimerPaused = false;
            updateTimerDisplay();
            stopTimer();

            timerInterval = setInterval(() => {
                if (!isTimerPaused) { // Only decrement if not paused
                    timeLeft--;
                    updateTimerDisplay();
                    
                    if (timeLeft <= 30) {
                        timerDiv.classList.add('low');
                    }

                    if (timeLeft <= 0) {
                        console.log("Timer finished, auto-ending game.");
                        stopTimer();
                        endGame(true);
                    }
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timeLeft = 120;
            isTimerPaused = false;
            timerDiv.classList.remove('low');
        }

        function pauseTimer() {
            console.log("‚è∏Ô∏è Timer paused (audio playing)");
            isTimerPaused = true;
        }

        function resumeTimer() {
            console.log("‚ñ∂Ô∏è Timer resumed (audio finished)");
            isTimerPaused = false;
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            const pauseIndicator = isTimerPaused ? ' ‚è∏Ô∏è' : '';
            timerDiv.textContent = `Time left: ${minutes}:${seconds.toString().padStart(2, '0')}${pauseIndicator}`;
        }
        
        // --- 8. End Game Function ---
        function endGame(isAutoEnd = false) {
            if (isAutoEnd) {
                updateStatus("Time's up! Evaluating...");
            } else {
                console.log("User clicked End Game.");
            }
            sendJson({ action: "end_game" });
            btnPushToTalk.disabled = true;
            btnEndGame.disabled = true;
        }

        // --- 9. Chat Log Function ---
        function addMessageToChat(role, text, isSpam = false) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message', role);
            if (isSpam) {
                msgDiv.classList.add('spam');
            }
            msgDiv.textContent = text;
            chatLog.appendChild(msgDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        
        // --- 10. Typing Indicator Functions ---
        function showTypingIndicator() {
            hideTypingIndicator();
            typingIndicator = document.createElement('div');
            typingIndicator.classList.add('typing-indicator');
            typingIndicator.innerHTML = '<span></span><span></span><span></span>';
            chatLog.appendChild(typingIndicator);
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        
        function hideTypingIndicator() {
            if (typingIndicator && typingIndicator.parentNode) {
                typingIndicator.parentNode.removeChild(typingIndicator);
                typingIndicator = null;
            }
        }

        // --- Helper Functions ---
        function sendJson(data) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("Sending JSON:", data);
                socket.send(JSON.stringify(data));
            }
        }

        function updateStatus(message) {
            console.log("Status:", message);
            statusDiv.textContent = message;
        }

        function enableAll(all = true) {
            if (all) {
                btnStartGame.disabled = false;
                scenarioSelect.disabled = false;
            }
            btnConnect.disabled = true;
            btnPushToTalk.disabled = true;
            btnEndGame.disabled = true;
        }
    </script>
</body>
</html>